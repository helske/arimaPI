{
    "contents" : "#' Compute different types of importance weights based on Jeffreys's prior\n#'\n#' These functions compute different types of importance weights based on Jeffreys's priors used in \\code{\\link{arima_pi}}.\n#'\n#' @export\n#' @rdname priors\n#' @name jeffreys\n#' @useDynLib arimaPI, .registration=TRUE\n#' @seealso \\code{\\link{arima_pi}}.\n#' @param psi vector containing the ar and ma parameters (in that order).\n#' @param xreg matrix or data frame containing the exogenous variables\n#' (not including the intercept which is always included for non-differenced series)\n#' @param p number of ar parameters\n#' @param q number of ma parameters\n#' @param n length of the time series\napprox_joint_jeffreys<-function(psi, xreg = NULL, p, q, n){\n\n  # Large sample approximation for Jeffreys joint prior p(beta,sigma,psi)=p(psi)/sigma=\n  # sqrt(|XinvVX'||I(psi)|), where I is the large sample approximation of information matrix\n  # Note that I_sigma,psi->0 when n->infinity so that term is omitted\n  # (equals to the case where they are assumed independent a priori)\n  #\n  phi <- if (p > 0) psi[1:p] else NULL\n  theta <- if (q > 0) psi[p + 1:q] else NULL\n  chol_im <- try(chol(information_arma(phi, theta)), silent = TRUE)\n  if (class(chol_im) != \"try-error\") {\n    sqrt_det <- prod(diag(chol_im))\n    if (!is.null(xreg)){\n      sqrt_det * sqrt(det(t(cbind(1, xreg)) %*% solve(toeplitz(acv_arma(phi, theta, n = n)),cbind(1,xreg))))\n    } else sqrt_det*sqrt(sum(solve(toeplitz(acv_arma(phi, theta, n = n)), matrix(1,nrow = n))))\n  }  else 0\n}\n#' @rdname priors\napprox_marginal_jeffreys<-function(psi, p, q){\n  # Large sample approximation for Jeffreys marginal prior p(psi) =\n  # sqrt(|I(psi)|), where I is the large sample approximation of information matrix\n  phi <- if (p > 0) psi[1:p] else NULL\n  theta <- if (q > 0) psi[p + 1:q] else NULL\n  chol_im <- try(chol(information_arma(phi, theta)), silent = TRUE)\n  if (class(chol_im) != \"try-error\") {\n    prod(diag(chol_im))\n  } else 0\n}\n#' @rdname priors\nexact_joint_jeffreys<-function(psi, xreg = NULL, p, q, n){\n  # Exact Jeffreys's joint prior\n  phi <- if(p>0) psi[1:p] else NULL\n  theta <- if(q>0) psi[(p+1):(p+q)] else NULL\n  V<-toeplitz(acv_arma(phi, theta,n = n))\n  invV<-solve(V)\n  dV<-dacv_arma(phi, theta,n = n)\n  informationMatrixPsi<-matrix(0,p+q,p+q)\n  informationMatrixPsiSigma<-numeric(p+q)\n  dVMatrices<-vector(\"list\",length=p+q)\n  dx<-1 + 0:(n - 1) * (n + 1)\n  for(i in 1:(p+q)){\n    dVMatrices[[i]]<-toeplitz(dV[,i])\n    informationMatrixPsiSigma[i]<-sum((invV %*% dVMatrices[[i]])[dx])\n  }\n  for(i in 1:(p+q))\n    for(j in 1:(p+q))\n      informationMatrixPsi[i,j]<-sum((invV %*% dVMatrices[[i]]%*%invV %*% dVMatrices[[j]])[dx])\n  if(!is.null(xreg)){\n    sqrt(det(t(cbind(1,xreg))%*%invV%*%cbind(1,xreg))*\n           det(informationMatrixPsi-1/(2*n)*informationMatrixPsiSigma%*%informationMatrixPsiSigma))\n  } else sqrt(matrix(1,ncol=n)%*%invV%*%matrix(1,nrow=n)*\n                det(informationMatrixPsi-1/(2*n)*informationMatrixPsiSigma%o%informationMatrixPsiSigma))\n}\n\n#' @rdname priors\nexact_marginal_jeffreys <- function(psi, p , q, n){\n  # Exact Jeffreys's marginal prior\n  phi <- if(p>0) psi[1:p] else NULL\n  theta <- if(q>0) psi[(p+1):(p+q)] else NULL\n  V<-toeplitz(acv_arma(phi, theta, n = n))\n  invV<-solve(V)\n  dV<-dacv_arma(phi, theta,n = n)\n  informationMatrixPsi<-matrix(0,p+q,p+q)\n  dVMatrices<-vector(\"list\",length=p+q)\n  dx<-1 + 0:(n - 1) * (n + 1)\n  for(i in 1:(p+q))\n    dVMatrices[[i]]<-toeplitz(dV[,i])\n  for(i in 1:(p+q))\n    for(j in 1:(p+q))\n      informationMatrixPsi[i,j]<-sum((invV %*% dVMatrices[[i]]%*%invV %*% dVMatrices[[j]])[dx])\n  sqrt(det(informationMatrixPsi))\n}\n\n",
    "created" : 1441960581104.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1190612172",
    "id" : "75166E0F",
    "lastKnownWriteTime" : 1441988687,
    "path" : "D:/repos/arimaPI/R/priors.R",
    "project_path" : "R/priors.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}