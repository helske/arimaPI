{
    "contents" : "arima\nfunction (x, order = c(0L, 0L, 0L), seasonal = list(order = c(0L, \n  0L, 0L), period = NA), xreg = NULL, include.mean = TRUE, \n  transform.pars = TRUE, fixed = NULL, init = NULL, method = c(\"CSS-ML\", \n    \"ML\", \"CSS\"), n.cond, SSinit = c(\"Gardner1980\", \"Rossignol2011\"), \n  optim.method = \"BFGS\", optim.control = list(), kappa = 1e+06) \n{\n  \"%+%\" <- function(a, b) .Call(C_TSconv, a, b)\n  SSinit <- match.arg(SSinit)\n  SS.G <- SSinit == \"Gardner1980\"\n  upARIMA <- function(mod, phi, theta) {\n    p <- length(phi)\n    q <- length(theta)\n    mod$phi <- phi\n    mod$theta <- theta\n    r <- max(p, q + 1L)\n    if (p > 0) \n      mod$T[1L:p, 1L] <- phi\n    if (r > 1L) \n      mod$Pn[1L:r, 1L:r] <- if (SS.G) \n        .Call(C_getQ0, phi, theta)\n    else .Call(C_getQ0bis, phi, theta, tol = 0)\n    else mod$Pn[1L, 1L] <- if (p > 0) \n      1/(1 - phi^2)\n    else 1\n    mod$a[] <- 0\n    mod\n  }\n  arimaSS <- function(y, mod) {\n    .Call(C_ARIMA_Like, y, mod, 0L, TRUE)\n  }\n  armafn <- function(p, trans) {\n    par <- coef\n    par[mask] <- p\n    trarma <- .Call(C_ARIMA_transPars, par, arma, trans)\n    if (is.null(Z <- tryCatch(upARIMA(mod, trarma[[1L]], \n      trarma[[2L]]), error = function(e) NULL))) \n      return(.Machine$double.xmax)\n    if (ncxreg > 0) \n      x <- x - xreg %*% par[narma + (1L:ncxreg)]\n    res <- .Call(C_ARIMA_Like, x, Z, 0L, FALSE)\n    s2 <- res[1L]/res[3L]\n    0.5 * (log(s2) + res[2L]/res[3L])\n  }\n  armaCSS <- function(p) {\n    par <- as.double(fixed)\n    par[mask] <- p\n    trarma <- .Call(C_ARIMA_transPars, par, arma, FALSE)\n    if (ncxreg > 0) \n      x <- x - xreg %*% par[narma + (1L:ncxreg)]\n    res <- .Call(C_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]], \n      as.integer(ncond), FALSE)\n    0.5 * log(res)\n  }\n  arCheck <- function(ar) {\n    p <- max(which(c(1, -ar) != 0)) - 1\n    if (!p) \n      return(TRUE)\n    all(Mod(polyroot(c(1, -ar[1L:p]))) > 1)\n  }\n  maInvert <- function(ma) {\n    q <- length(ma)\n    q0 <- max(which(c(1, ma) != 0)) - 1L\n    if (!q0) \n      return(ma)\n    roots <- polyroot(c(1, ma[1L:q0]))\n    ind <- Mod(roots) < 1\n    if (all(!ind)) \n      return(ma)\n    if (q0 == 1) \n      return(c(1/ma[1L], rep.int(0, q - q0)))\n    roots[ind] <- 1/roots[ind]\n    x <- 1\n    for (r in roots) x <- c(x, 0) - c(0, x)/r\n    c(Re(x[-1L]), rep.int(0, q - q0))\n  }\n  series <- deparse(substitute(x))\n  if (NCOL(x) > 1L) \n    stop(\"only implemented for univariate time series\")\n  method <- match.arg(method)\n  x <- as.ts(x)\n  if (!is.numeric(x)) \n    stop(\"'x' must be numeric\")\n  storage.mode(x) <- \"double\"\n  dim(x) <- NULL\n  n <- length(x)\n  if (!missing(order)) \n    if (!is.numeric(order) || length(order) != 3L || any(order < \n        0)) \n      stop(\"'order' must be a non-negative numeric vector of length 3\")\n  if (!missing(seasonal)) \n    if (is.list(seasonal)) {\n      if (is.null(seasonal$order)) \n        stop(\"'seasonal' must be a list with component 'order'\")\n      if (!is.numeric(seasonal$order) || length(seasonal$order) != \n          3L || any(seasonal$order < 0L)) \n        stop(\"'seasonal$order' must be a non-negative numeric vector of length 3\")\n    }\n  else if (is.numeric(order)) {\n    if (length(order) == 3L) \n      seasonal <- list(order = seasonal)\n    else (\"'seasonal' is of the wrong length\")\n  }\n  else stop(\"'seasonal' must be a list with component 'order'\")\n  if (is.null(seasonal$period) || is.na(seasonal$period) || \n      seasonal$period == 0) \n    seasonal$period <- frequency(x)\n  arma <- as.integer(c(order[-2L], seasonal$order[-2L], seasonal$period, \n    order[2L], seasonal$order[2L]))\n  narma <- sum(arma[1L:4L])\n  xtsp <- tsp(x)\n  tsp(x) <- NULL\n  Delta <- 1\n  for (i in seq_len(order[2L])) Delta <- Delta %+% c(1, -1)\n  for (i in seq_len(seasonal$order[2L])) Delta <- Delta %+% \n    c(1, rep.int(0, seasonal$period - 1), -1)\n  Delta <- -Delta[-1L]\n  nd <- order[2L] + seasonal$order[2L]\n  n.used <- sum(!is.na(x)) - length(Delta)\n  if (is.null(xreg)) {\n    ncxreg <- 0L\n  }\n  else {\n    nmxreg <- deparse(substitute(xreg))\n    if (NROW(xreg) != n) \n      stop(\"lengths of 'x' and 'xreg' do not match\")\n    ncxreg <- NCOL(xreg)\n    xreg <- as.matrix(xreg)\n    storage.mode(xreg) <- \"double\"\n  }\n  class(xreg) <- NULL\n  if (ncxreg > 0L && is.null(colnames(xreg))) \n    colnames(xreg) <- if (ncxreg == 1L) \n      nmxreg\n  else paste0(nmxreg, 1L:ncxreg)\n  if (include.mean && (nd == 0L)) {\n    xreg <- cbind(intercept = rep(1, n), xreg = xreg)\n    ncxreg <- ncxreg + 1L\n  }\n  if (method == \"CSS-ML\") {\n    anyna <- anyNA(x)\n    if (ncxreg) \n      anyna <- anyna || anyNA(xreg)\n    if (anyna) \n      method <- \"ML\"\n  }\n  if (method == \"CSS\" || method == \"CSS-ML\") {\n    ncond <- order[2L] + seasonal$order[2L] * seasonal$period\n    ncond1 <- order[1L] + seasonal$period * seasonal$order[1L]\n    ncond <- ncond + if (!missing(n.cond)) \n      max(n.cond, ncond1)\n    else ncond1\n  }\n  else ncond <- 0\n  if (is.null(fixed)) \n    fixed <- rep(NA_real_, narma + ncxreg)\n  else if (length(fixed) != narma + ncxreg) \n    stop(\"wrong length for 'fixed'\")\n  mask <- is.na(fixed)\n  no.optim <- !any(mask)\n  if (no.optim) \n    transform.pars <- FALSE\n  if (transform.pars) {\n    ind <- arma[1L] + arma[2L] + seq_len(arma[3L])\n    if (any(!mask[seq_len(arma[1L])]) || any(!mask[ind])) {\n      warning(\"some AR parameters were fixed: setting transform.pars = FALSE\")\n      transform.pars <- FALSE\n    }\n  }\n  init0 <- rep.int(0, narma)\n  parscale <- rep(1, narma)\n  if (ncxreg) {\n    cn <- colnames(xreg)\n    orig.xreg <- (ncxreg == 1L) || any(!mask[narma + 1L:ncxreg])\n    if (!orig.xreg) {\n      S <- svd(na.omit(xreg))\n      xreg <- xreg %*% S$v\n    }\n    dx <- x\n    dxreg <- xreg\n    if (order[2L] > 0L) {\n      dx <- diff(dx, 1L, order[2L])\n      dxreg <- diff(dxreg, 1L, order[2L])\n    }\n    if (seasonal$period > 1L & seasonal$order[2L] > 0) {\n      dx <- diff(dx, seasonal$period, seasonal$order[2L])\n      dxreg <- diff(dxreg, seasonal$period, seasonal$order[2L])\n    }\n    fit <- if (length(dx) > ncol(dxreg)) \n      lm(dx ~ dxreg - 1, na.action = na.omit)\n    else list(rank = 0L)\n    if (fit$rank == 0L) {\n      fit <- lm(x ~ xreg - 1, na.action = na.omit)\n    }\n    isna <- is.na(x) | apply(xreg, 1L, anyNA)\n    n.used <- sum(!isna) - length(Delta)\n    init0 <- c(init0, coef(fit))\n    ses <- summary(fit)$coefficients[, 2L]\n    parscale <- c(parscale, 10 * ses)\n  }\n  if (n.used <= 0) \n    stop(\"too few non-missing observations\")\n  if (!is.null(init)) {\n    if (length(init) != length(init0)) \n      stop(\"'init' is of the wrong length\")\n    if (any(ind <- is.na(init))) \n      init[ind] <- init0[ind]\n    if (method == \"ML\") {\n      if (arma[1L] > 0) \n        if (!arCheck(init[1L:arma[1L]])) \n          stop(\"non-stationary AR part\")\n      if (arma[3L] > 0) \n        if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]])) \n          stop(\"non-stationary seasonal AR part\")\n      if (transform.pars) \n        init <- .Call(C_ARIMA_Invtrans, as.double(init), \n          arma)\n    }\n  }\n  else init <- init0\n  coef <- as.double(fixed)\n  if (!(\"parscale\" %in% names(optim.control))) \n    optim.control$parscale <- parscale[mask]\n  if (method == \"CSS\") {\n    res <- if (no.optim) \n      list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))\n    else optim(init[mask], armaCSS, method = optim.method, \n      hessian = TRUE, control = optim.control)\n    if (res$convergence > 0) \n      warning(gettextf(\"possible convergence problem: optim gave code = %d\", \n        res$convergence), domain = NA)\n    coef[mask] <- res$par\n    trarma <- .Call(C_ARIMA_transPars, coef, arma, FALSE)\n    mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa, \n      SSinit)\n    if (ncxreg > 0) \n      x <- x - xreg %*% coef[narma + (1L:ncxreg)]\n    arimaSS(x, mod)\n    val <- .Call(C_ARIMA_CSS, x, arma, trarma[[1L]], trarma[[2L]], \n      as.integer(ncond), TRUE)\n    sigma2 <- val[[1L]]\n    var <- if (no.optim) \n      numeric()\n    else solve(res$hessian * n.used)\n  }\n  else {\n    if (method == \"CSS-ML\") {\n      res <- if (no.optim) \n        list(convergence = 0L, par = numeric(), value = armaCSS(numeric()))\n      else optim(init[mask], armaCSS, method = optim.method, \n        hessian = FALSE, control = optim.control)\n      if (res$convergence == 0) \n        init[mask] <- res$par\n      if (arma[1L] > 0) \n        if (!arCheck(init[1L:arma[1L]])) \n          stop(\"non-stationary AR part from CSS\")\n      if (arma[3L] > 0) \n        if (!arCheck(init[sum(arma[1L:2L]) + 1L:arma[3L]])) \n          stop(\"non-stationary seasonal AR part from CSS\")\n      ncond <- 0L\n    }\n    if (transform.pars) {\n      init <- .Call(C_ARIMA_Invtrans, init, arma)\n      if (arma[2L] > 0) {\n        ind <- arma[1L] + 1L:arma[2L]\n        init[ind] <- maInvert(init[ind])\n      }\n      if (arma[4L] > 0) {\n        ind <- sum(arma[1L:3L]) + 1L:arma[4L]\n        init[ind] <- maInvert(init[ind])\n      }\n    }\n    trarma <- .Call(C_ARIMA_transPars, init, arma, transform.pars)\n    mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa, \n      SSinit)\n    res <- if (no.optim) \n      list(convergence = 0, par = numeric(), value = armafn(numeric(), \n        as.logical(transform.pars)))\n    else optim(init[mask], armafn, method = optim.method, \n      hessian = TRUE, control = optim.control, trans = as.logical(transform.pars))\n    if (res$convergence > 0) \n      warning(gettextf(\"possible convergence problem: optim gave code = %d\", \n        res$convergence), domain = NA)\n    coef[mask] <- res$par\n    if (transform.pars) {\n      if (arma[2L] > 0L) {\n        ind <- arma[1L] + 1L:arma[2L]\n        if (all(mask[ind])) \n          coef[ind] <- maInvert(coef[ind])\n      }\n      if (arma[4L] > 0L) {\n        ind <- sum(arma[1L:3L]) + 1L:arma[4L]\n        if (all(mask[ind])) \n          coef[ind] <- maInvert(coef[ind])\n      }\n      if (any(coef[mask] != res$par)) {\n        oldcode <- res$convergence\n        res <- optim(coef[mask], armafn, method = optim.method, \n          hessian = TRUE, control = list(maxit = 0L, \n            parscale = optim.control$parscale), trans = TRUE)\n        res$convergence <- oldcode\n        coef[mask] <- res$par\n      }\n      A <- .Call(C_ARIMA_Gradtrans, as.double(coef), arma)\n      A <- A[mask, mask]\n      var <- crossprod(A, solve(res$hessian * n.used, A))\n      coef <- .Call(C_ARIMA_undoPars, coef, arma)\n    }\n    else var <- if (no.optim) \n      numeric()\n    else solve(res$hessian * n.used)\n    trarma <- .Call(C_ARIMA_transPars, coef, arma, FALSE)\n    mod <- makeARIMA(trarma[[1L]], trarma[[2L]], Delta, kappa, \n      SSinit)\n    val <- if (ncxreg > 0L) \n      arimaSS(x - xreg %*% coef[narma + (1L:ncxreg)], mod)\n    else arimaSS(x, mod)\n    sigma2 <- val[[1L]][1L]/n.used\n  }\n  value <- 2 * n.used * res$value + n.used + n.used * log(2 * \n      pi)\n  aic <- if (method != \"CSS\") \n    value + 2 * sum(mask) + 2\n  else NA\n  nm <- NULL\n  if (arma[1L] > 0L) \n    nm <- c(nm, paste0(\"ar\", 1L:arma[1L]))\n  if (arma[2L] > 0L) \n    nm <- c(nm, paste0(\"ma\", 1L:arma[2L]))\n  if (arma[3L] > 0L) \n    nm <- c(nm, paste0(\"sar\", 1L:arma[3L]))\n  if (arma[4L] > 0L) \n    nm <- c(nm, paste0(\"sma\", 1L:arma[4L]))\n  if (ncxreg > 0L) {\n    nm <- c(nm, cn)\n    if (!orig.xreg) {\n      ind <- narma + 1L:ncxreg\n      coef[ind] <- S$v %*% coef[ind]\n      A <- diag(narma + ncxreg)\n      A[ind, ind] <- S$v\n      A <- A[mask, mask]\n      var <- A %*% var %*% t(A)\n    }\n  }\n  names(coef) <- nm\n  if (!no.optim) \n    dimnames(var) <- list(nm[mask], nm[mask])\n  resid <- val[[2L]]\n  tsp(resid) <- xtsp\n  class(resid) <- \"ts\"\n  structure(list(coef = coef, sigma2 = sigma2, var.coef = var, \n    mask = mask, loglik = -0.5 * value, aic = aic, arma = arma, \n    residuals = resid, call = match.call(), series = series, \n    code = res$convergence, n.cond = ncond, nobs = n.used, \n    model = mod), class = \"Arima\")\n}\n<bytecode: 0x000000000be3d728>\n  <environment: namespace:stats>",
    "created" : 1441957836670.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2969475434",
    "id" : "2EE81",
    "lastKnownWriteTime" : 7011605692497750387,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}