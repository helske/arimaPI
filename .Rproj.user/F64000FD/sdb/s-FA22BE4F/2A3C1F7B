{
    "contents" : "#' Compute Bayesian prediction intervals for ARIMA processes with exogenous variables using importance sampling\n#'\n#' Function \\code{arima_pi} computes prediction intervals for ARIMA processes\n#' with exogenous variables using importance sampling. For regression coefficients,\n#' diffuse (uninformative) prior is used, whereas multiple options for\n#' prior distributions for ARMA coefficients are supported.\n#'\n#' @export\n#' @import KFAS\n#' @name arima_pi\n#\n#' @param y vector containing the time series\n#' @param xreg matrix or data frame containing the exogenous variables\n#' (not including the intercept which is always included for non-differenced series)\n#' @param order vector of length 3 with values p,d,q\n#' corresponding to the number of AR parameters, degree of differencing and number of MA parameters.\n#' @param nsim number of simulations used in importance sampling.\n#' @param n.ahead length of the forecast horizon.\n#' @param level desired frequentist coverage probability of the prediction intervals.\n#' @param median compute the median of the prediction interval.\n#' @param se_limits compute the standard errors of the prediction interval limits.\n#' @param priors priors to be used in importance sampling. Multiple choices are allowed. See \\code{\\link{jeffreys}} for details.\n#' @param custom_prior function for computing custom prior.\n#' First argument must be a vector containing the AR and MA parameters (in that order).\n#' @param custom_prior_args list containing additional arguments to \\code{custom_prior}.\n#' @param last_only compute the prediction intervals only for the last prediction step.\n#' @param return_weights Return (scaled) weights used in importance sampling.\n#' @param ... Additional arguments for \\code{arima}.\n#' @return a list containing the prediction intervals.\n#' @examples\n#'\n#' pred_arima <- predict(arima(lh, order = c(3,0,0)), n.ahead = 12, se.fit = TRUE)\n#' pred_arima <- cbind(pred = pred_arima$pred,\n#'  lwr = pred_arima$pred - qnorm(0.975)*pred_arima$se^2,\n#'  upr = pred_arima$pred + qnorm(0.975)*pred_arima$se^2)\n#'\n#' pred <- arima_pi(lh, order = c(3,0,0), n.ahead = 12, prior = \"uniform\")\n#'\n#' ts.plot(ts.union(lh,pred_arima, pred$uniform[,1:3]), col = c(1,2,2,2,3,3,3),\n#' lty = c(1,1,2,2,1,2,2))\narima_pi <- function(y, order, xreg = NULL, n.ahead = 1, level = 0.95, median = TRUE, se_limits = TRUE,\n  priors = c(\"uniform\", \"approx_joint_jeffreys\", \"approx_marginal_jeffreys\", \"exact_joint_jeffreys\", \"exact_marginal_jeffreys\"),\n  custom_prior, custom_prior_args, nsim = 1000, last_only = FALSE, return_weights = FALSE, ...){\n\n  distfkt <- function(a, prob, ey, sdy, w){\n    sum(w * pnorm(q = a, mean = ey, sd = sdy)) - prob\n  }\n\n  priors <- match.arg(priors, several.ok = TRUE)\n  if (!missing(custom_prior))\n    priors <- c(priors, \"custom\")\n  n <- length(y)\n  fit <- arima(y, order, xreg = xreg[1:n, ], ...)\n  if (fit$code != 0 || sum(diag(fit$var.coef) < 1e-7) != 0)\n  {\n    stop(\"arima function returned non-convergence or coefficient variances smaller than 1e-7.\")\n  }\n\n  p <- order[1]\n  d <- order[2]\n  q <- order[3]\n  npar <- p + q\n  psihat <- as.numeric(fit$coef[1:npar])\n  psivar <- matrix(fit$var.coef[1:npar, 1:npar], npar, npar)\n  psivarchol <- try(t(chol(psivar)), TRUE)\n  if (class(psivarchol) == \"try-error\" || any(diag(psivarchol) < 1e-12))\n    stop(\"Covariance matrix fit$var.coef[1:npar, 1:npar] obtained from arima function is not positive definite.\")\n\n  psisim <- array(rnorm(n = nsim * npar),c(nsim, npar))\n  for (i in 1:nsim)\n    psisim[i,] <- psihat + psivarchol %*% psisim[i, ]\n\n  sigma2hat <- fit$sigma2\n  k <- length(fit$coef) - npar\n  sigmasim <- 1/rchisq(nsim, df = n - k)\n\n  #stationarity\n  if (p > 0) {\n    w <- apply(matrix(abs(apply(cbind(rep(1, nsim),-psisim[, 1:p]), 1, polyroot)) > 1, p, nsim), 2, sum) == p\n  } else w <- rep(1, nsim)\n  #invertibility\n  if (q > 0) {\n    w <- w * apply(matrix(abs(apply(cbind(rep(1, nsim), psisim[, (p + 1):(p + q)]),1, polyroot)) > 1, q, nsim), 2, sum) == q\n  }\n\n  y <- c(y, rep(NA, n.ahead))\n  ey <- sdy <- matrix(0,n.ahead, nsim)\n  psivarinv <- crossprod(solve(t(psivarchol)))\n\n  valid <- which(w > 0)[1]\n  valid_ar <- if (p > 0) psisim[valid, 1:p] else NULL\n  valid_ma <- if ( q > 0) psisim[valid, (p + 1):(p + q)] else NULL\n  if (is.null(xreg)) {\n    model <- SSModel(y ~ SSMarima(ar = valid_ar, ma = valid_ma, d = order[2], Q = 1), H = 0)\n  } else {\n    model <- SSModel(y ~ xreg + SSMarima(ar = valid_ar, ma = valid_ma, d = order[2], Q = 1), H = 0)\n  }\n  kd <- k + d\n  m <- max(p, q + 1)\n  nd <- (kd + 1):(kd + m)\n\n  w <- matrix(w, nsim, length(priors))\n  colnames(w) <- priors\n  for (i in which(w[, 1] > 0)) {\n    if (q > 0)\n      model$R[(kd + 2):(kd + 1 + q)] <- psisim[i, (p + 1):npar]\n    if (p > 0)\n      model$T[(kd + 1):(kd + p),kd + 1,] = psisim[i, 1:p]\n    model$P1[nd, nd] <- solve(a = diag(m^2) - as.matrix(kronecker(model$T[nd, nd, ], model$T[nd, nd, ])),\n      b = c(model$R[nd] %*% t(model$R[nd])))\n\n    out <- KFS(model, filtering = \"mean\", smoothing = \"none\")\n    if (out$d > 0) {\n      s2 <- sum(out$v[1:out$d][out$Finf == 0]^2/out$F[1:out$d][out$Finf == 0]) +\n        sum(out$v[(out$d + 1):n]^2/out$F[(out$d + 1):n])\n    } else s2 <- sum(c(out$v[1:n])^2/out$F[1:n])\n\n    sigmasim[i] <-  sqrt(s2 * sigmasim[i])\n    ey[1:n.ahead,i] <- out$m[(n + 1):(n + n.ahead)]\n    sdy[1:n.ahead,i] <- sqrt(out$P_mu[(n + 1):(n + n.ahead)]) * sigmasim[i]\n\n    #s2 is replaced by (s2/n)/sigma2hat so that w>>0\n    detVXinvX <- prod(c(out$Finf[out$Finf > 0], out$F[1:out$d][out$Finf == 0], out$F[(out$d + 1):n]))\n    weight <-\n      (((s2 / n) / sigma2hat)^(-0.5 * (n - k)) / sqrt(detVXinvX)) /\n      exp(-0.5 * t(psisim[i,] - psihat) %*% psivarinv %*% (psisim[i, ] - psihat))\n\n    if(\"uniform\" %in% priors)\n      w[i, \"uniform\"] <- weight\n    if(\"exact_joint_jeffreys\" %in% priors)\n      w[i, \"exact_joint_jeffreys\"] <- weight * exact_joint_jeffreys(psisim[i, ], xreg, p, q, n)\n    if(\"exact_marginal_jeffreys\" %in% priors)\n      w[i, \"exact_marginal_jeffreys\"] <- weight * exact_marginal_jeffreys(psisim[i, ], p, q, n)\n    if(\"approx_joint_jeffreys\" %in% priors)\n      w[i, \"approx_joint_jeffreys\"] <- weight * approx_joint_jeffreys(psisim[i, ], xreg, p, q, n)\n    if(\"approx_marginal_jeffreys\" %in% priors)\n      w[i, \"approx_marginal_jeffreys\"] <- weight * approx_marginal_jeffreys(psisim[i, ], p, q)\n    if(\"custom\" %in% priors)\n      w[i, \"custom\"] <- weight * do.call(custom_prior, list(psisim[i, ], custom_prior_args))\n  }\n\n  out <- vector(\"list\",length(priors))\n  names(out) <- priors\n  for (i in 1:length(priors)) {\n    w[, i] <- w[, i]/sum(w[, i])\n    if (!last_only) {\n      out[[i]] <- ts(matrix(0, n.ahead, 2 + median + 2 * se_limits), end = end(model$y), frequency = frequency(model$y))\n      colnames(out[[i]]) <- c(if (median) \"median\", \"lwr\", \"upr\", if (se_limits) c(\"se_lwr\", \"se_upr\"))\n      if (sum(is.na(w[, i])) == 0)\n      {\n        nz_w <- w[w[, i] != 0, i]\n        for (j in 1:n.ahead)\n        {\n          nz_ey <- ey[j, w[, i] != 0]\n          nz_sdy <- sdy[j, w[, i] != 0]\n          interval <- c(mean(nz_ey) + c(-1, 1) * 8 * max(nz_sdy))\n          out[[i]][j, \"lwr\"] <- uniroot(distfkt, interval = interval, prob = (1 - level) / 2,\n            ey = nz_ey, sdy = nz_sdy,w = nz_w, tol = 1e-12)$root\n          out[[i]][j, \"upr\"] <- uniroot(distfkt,  interval = interval, prob = 1 - (1 - level) / 2,\n            ey = nz_ey, sdy = nz_sdy,w = nz_w, tol = 1e-12)$root\n          if (median) {\n            out[[i]][j, \"median\"] <- uniroot(distfkt,  interval = interval, prob = 0.5,\n              ey = nz_ey, sdy = nz_sdy,w = nz_w, tol = 1e-12)$root\n          }\n          if (se_limits) {\n            out[[i]][j, \"se_lwr\"] <-\n              sqrt(sum((nz_w * (((1 - level) / 2) - pnorm(q = out[[i]][j, 1], nz_ey, nz_sdy)))^2) / (nsim - 1)) /\n              (sum(nz_w * dnorm(x = out[[i]][j, 1], nz_ey, nz_sdy)/sqrt(nsim)))\n            out[[i]][j, \"se_upr\"] <-\n              sqrt(sum((nz_w * ((1 - (1 - level) / 2) - pnorm(q = out[[i]][j, 2], nz_ey, nz_sdy)))^2) / (nsim - 1)) /\n              (sum(nz_w * dnorm(x = out[[i]][j, 2], nz_ey, nz_sdy)/sqrt(nsim)))\n          }\n        }\n      }\n\n    } else {\n      out[[i]] <- ts(numeric(2 + median + 2 * se_limits), end = end(model$y), frequency = frequency(model$y))\n      names(out[[i]]) <- c(if (median) \"median\", \"lwr\", \"upr\", if (se_limits) c(\"se_lwr\", \"se_upr\"))\n      if (sum(is.na(w[, i])) == 0)\n      {\n        nz_w <- w[w[, i] != 0, i]\n        nz_ey <- ey[w[, i] != 0]\n        nz_sdy <- sdy[w[, i] != 0]\n        interval <- c(mean(nz_ey) + c(-1, 1) * 8 * max(nz_sdy))\n        out[[i]][\"lwr\"] <- uniroot(distfkt, interval = interval, prob = (1 - level) / 2,\n          ey = nz_ey, sdy = nz_sdy,w = nz_w, tol = 1e-12)$root\n        out[[i]][\"upr\"] <- uniroot(distfkt,  interval = interval, prob = 1 - (1 - level) / 2,\n          ey = nz_ey, sdy = nz_sdy,w = nz_w, tol = 1e-12)$root\n        if (median) {\n          out[[i]][\"median\"] <- uniroot(distfkt,  interval = interval, prob = 0.5,\n            ey = nz_ey, sdy = nz_sdy,w = nz_w, tol = 1e-12)$root\n        }\n        if (se_limits) {\n          out[[i]][\"se_lwr\"] <-\n            sqrt(sum((nz_w * (((1 - level) / 2) - pnorm(q = out[[i]][1], nz_ey, nz_sdy)))^2) / (nsim - 1)) /\n            (sum(nz_w * dnorm(x = out[[i]][1], nz_ey, nz_sdy)/sqrt(nsim)))\n          out[[i]][\"se_upr\"] <-\n            sqrt(sum((nz_w * ((1 - (1 - level) / 2) - pnorm(q = out[[i]][2], nz_ey, nz_sdy)))^2) / (nsim - 1)) /\n            (sum(nz_w * dnorm(x = out[[i]][2], nz_ey, nz_sdy)/sqrt(nsim)))\n        }\n\n      }\n    }\n  }\n  if (return_weights)\n    out <- list(pred = out, weights = w)\n  out$fit <- fit\n  out\n}",
    "created" : 1441960574234.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2881958597",
    "id" : "2A3C1F7B",
    "lastKnownWriteTime" : 1441988691,
    "path" : "D:/repos/arimaPI/R/arima_pi.R",
    "project_path" : "R/arima_pi.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}